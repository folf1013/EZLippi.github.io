---
layout: post
title: map缓存设计案列
description: map缓存设计案例
keywords: redis
categories : [缓存]
tags : [redis]
---

为了提高效率和性能，需要设计缓存。决定为卡片添加缓存。卡片有基本字段，有复杂对象
分配成员，自定义字段，子任务等。

# 要求 

## 读
- 能快速获取单张卡片全部信息（卡片详情）。
- 能批量获取很多张（500张）卡片部分信息（一张面板多张卡片，用户工作台多张卡片）。

## 写
- 更新速度快。
- 更新操作保持原子性，避免加锁。
- 更新操作避免每次先读库，然后写缓存，尽量直接更新缓存。

# 方案

## 第一种:卡片作为一个整体缓存

- 结构
flag,<issueId,整张卡片json>。
- 优点
每次读取一张卡片，批量卡片读取速度快。
- 缺点
更新效率低，只能每次读库写缓存(慢)，加分布锁（读缓存，修改，写缓存）。

## 第二种:卡片分为4部分缓存。

- 结构
issueId,<标识(基本字段/自定义字段/分配成员/子任务),相关标识对应的json>。

- 特点
粒度居中，批量读写比上一种慢，但是比下一种快，更新粒度小，但是不能避免读库或者加锁。

## 第三种:分属性存储

- 结构
issueId,<priority,value>  
fieldId,<priority,value>  
childId,<priority,value>    
userId,<priority,value>  

- 优点
字段更新可以变成原子操作。
- 缺点
批量获取速度慢，obj到map的相互转换只支持基本类型，复杂类型需要拆分存入，操作较复杂。

## 最终方案

通过读写性能测试，三种方案都不能同时满足读写的要求。最后采用了第一种和第三种的结合。

![](/images/pimg/issueredis.png)

- 摘要缓存是卡片的部分字段，主要用于卡片大批量读取。
- 单张卡片全部信息的读取，是通过卡片整体缓存。
- 更新时，先更新卡片整体缓存，而卡片摘要缓存是卡片整体缓存进行更新。


- 优点
兼并了第一种方案和第三种方案的优点。读走卡片缓存，速度很快，写走整体缓存，保持了操作的原子性。
- 缺点
维护俩套缓存，成本变大。卡片整体缓存map与object的转换，只支持基本类型，复杂类型需要转换，操作复杂。 

# 总结

- 粗粒度和细粒度的缓存相结，兼并俩种优点，粗粒度的更新来源于细粒度。
- 保持写的原则性，避免读库或者加锁。







